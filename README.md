# JWT Authentication and Authorization Flow

## Теория и заметки по реализации

**Аутентификация** - в нашем случае, это процедура проверки подлинности пользователя при помощи логина и пароля.

**Авторизация** - предоставление пользователю прав на выполнение определённых действий (доступ к защищенным маршрутам). У пользователя могут быть специфичные роли с разными уровнями доступа.

### Сервер

Нам нужно создать маршруты для регистрации пользователя и для аутентификации пользователя (логин, логаут).

В контроллере обробатывающий регистрацию используем bcrypt (или аналоги) для хэширования пароля (нельзя хранить пароли в БД в чистом виде). В этот обработчик, как минимум должны передать уникальный идентификатор пользователя (имя, никнейм или email) и пароль. Если имя(email) уже существует в БД отвечаем со статусом 409 (Conflict).

Для логина, в теле запроса, также передадим имя (email) пользователя и пароль (если какое либо поле не предано отдаем статус 400). Если в БД не находим пользователя с указаным именем, возвращаем ответ со статусом 401 (Unauthorized). Если пользователь существует сравниваем пароли `bcrypt.compare()`. Если пароль совпадает то генерируем два JWT токена (accessToken и refreshToken) и отправляем их на клиент. Если нет, то отдаем статус 401.

#### Access-токен

Живет примерно 15-30 минут. Чем это время меньше тем безопаснее. Создается во время авторизации (логин). Клиент использует его для доступа к API пока не истечет срок жизни токена. Верифицируем при помощи middleware при каждом запросе (в этом примере это `middleware/verifyJWT.js`). Выпускаем новый Access токен при запросе к API refresh (в этом примере это `controllers/refreshTokenController.js`). Храним в памяти приложения. Хранить в localStorage и cookies без httpOnly (устанавливает только сервер) не безопасно.

В verifyJWT мы проверяем есть ли в запросе заголовок Authorization с Access токеном. Если есть то сверяем его `jwt.verify()` и добавляем нужные данные в запрос (в нашем примере в поля req.user и req.roles).

#### Refresh-токен

Живет уже дольше - 15-60 дней. Создается во время авторизации (логин). Клиент использует refreshToken для получения нового accessToken'а. Верифицируем при помощи запроса к endpointэ'у и БД. У него должно быть укзанное время жизни (не бесконечное), либо возможность его удалить при logout'е. Если в течении времени жизни refreshToken'а пользователь не посещал сервис, то ему придется заново авторизоваться при помощи логина (email) и пароля. Храним в httpOnly cookies, чтобы при помощи JS нельзя было получить к нему доступ. То есть куки устанваливает непосредственно сервер. Refresh-токен записывается в базу данных на сервере и получается своего рода сессия. Туда же можно записывать, например, IP адресс из которого произошло подключение (или браузер) и если при заходе будет новый адрес, то можно отправить письмо пользователю, что в его учетку зашли с нового устройства.

В качестве payload для JWT можем сипользовать **имя(никнейм, email)** и **роли** (права доступа), если нужно, но не пароль. Хорошей практикой будет использовать цифровой индикатор для описания роли, а не названия роли (user, editor, moderator, admin). Роли есть смысл передавать только для accessToken'а, но не для refreshToken'а (он нужен только для выпуска нового accessToken).

Вредоносные атаки, которые нужно учитывать: [XSS](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%B8%D0%BD%D0%B3) и [CSRF](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0)

#### Заметки по реализации

При авторизации (login) `controllers/authController.js` устанваливаем cookies с опциями httpOnly, sameSite, secure, maxAge.

Логика для logout'а пользователя описана в `controllers/logoutController.js` где мы удаляем refreshToken пользователя из БД и делаем `res.clearCookie()` (с опцией httpOnly и secure для https).

Также не стоит забывать про CORS ошибки. В этой реализации используем кастом credentials middleware (в ответе мы устанавливаем заголовок 'Access-Control-Allow-Credentials') и cors middleware (из npm) с опциями. Применяем в указаном порядке - сначала credentials, потом cors.

Роли для авторизации описываем в `config/roles_list.js`. Также модель User должна содержать поле, где указываем роли пользователя по умолчанию при создании пользователя.

Проверяем роли при помощи verifyRoles middleware куда предаем массив с ролями. В этой функции мы смотрим есть ли совпадения значений у переданного как аргумент массива и массива req.roles. Если совпадений нет то отдаем ответ со статусом 401, иначе next(). Пример использования verifyRoles middleware смотрим в `routes/api/employees.js`.

### Клиент
